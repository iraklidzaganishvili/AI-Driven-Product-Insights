import type { Tensor3D, Tensor4D } from '@tensorflow/tfjs-core';
import type { PrivateUpscaleArgs, ModelPackage, BASE64, TENSOR, YieldedIntermediaryValue, InternalConfig } from './types';
import type { FixedShape4D, TF } from '../../../shared/src/types';
import { GraphModel, LayersModel } from '@tensorflow/tfjs';
export declare const getPercentageComplete: (row: number, col: number, columns: number, total: number) => number;
export declare const executeModel: (model: LayersModel | GraphModel, pixels: Tensor4D) => Tensor4D;
export declare function processPixels<T extends TF, I>(tf: T, pixels: Tensor4D, { output, progress, progressOutput, }: Pick<PrivateUpscaleArgs, 'output' | 'progress' | 'progressOutput'>, modelPackage: ModelPackage, { originalImageSize, patchSize, padding, }: {
    originalImageSize: FixedShape4D;
} & Pick<PrivateUpscaleArgs, 'patchSize' | 'padding'>, { tensorAsBase64, }: Pick<InternalConfig<T, I>, 'tensorAsBase64'>): AsyncGenerator<YieldedIntermediaryValue, Tensor3D>;
export declare function upscale<T extends TF, I>(tf: T, input: I, args: Omit<PrivateUpscaleArgs, 'output'> & {
    output: BASE64;
}, modelPackage: ModelPackage, internalConfig: Pick<InternalConfig<T, I>, 'getImageAsTensor' | 'tensorAsBase64'>): AsyncGenerator<YieldedIntermediaryValue, string>;
export declare function upscale<T extends TF, I>(tf: T, input: I, args: Omit<PrivateUpscaleArgs, 'output'> & {
    output: TENSOR;
}, modelPackage: ModelPackage, internalConfig: Pick<InternalConfig<T, I>, 'getImageAsTensor' | 'tensorAsBase64'>): AsyncGenerator<YieldedIntermediaryValue, Tensor3D>;
export declare function upscale<T extends TF, I>(tf: T, input: I, args: Omit<PrivateUpscaleArgs, 'output'> & {
    output: BASE64 | TENSOR;
}, modelPackage: ModelPackage, internalConfig: Pick<InternalConfig<T, I>, 'getImageAsTensor' | 'tensorAsBase64'>): AsyncGenerator<YieldedIntermediaryValue, string | Tensor3D>;
export declare function cancellableUpscale<T extends TF, I>(tf: T, input: I, { signal, awaitNextFrame, ...args }: Omit<PrivateUpscaleArgs, 'output'> & {
    output: TENSOR;
}, internalArgs: ModelPackage & {
    signal: AbortSignal;
}, internalConfig: InternalConfig<T, I>): Promise<Tensor3D>;
export declare function cancellableUpscale<T extends TF, I>(tf: T, input: I, { signal, awaitNextFrame, ...args }: Omit<PrivateUpscaleArgs, 'output'> & {
    output: BASE64;
}, internalArgs: ModelPackage & {
    signal: AbortSignal;
}, internalConfig: InternalConfig<T, I>): Promise<string>;
export declare function cancellableUpscale<T extends TF, I>(tf: T, input: I, { signal, awaitNextFrame, ...args }: Omit<PrivateUpscaleArgs, 'output'> & {
    output: BASE64 | TENSOR;
}, internalArgs: ModelPackage & {
    signal: AbortSignal;
}, internalConfig: InternalConfig<T, I>): Promise<Tensor3D | string>;
//# sourceMappingURL=upscale.d.ts.map