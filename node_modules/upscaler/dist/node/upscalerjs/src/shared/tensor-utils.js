"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.concatTensors = exports.getCopyOfInput = exports.tensorAsClampedArray = exports.scaleIncomingPixels = exports.getWidthAndHeight = exports.scaleOutput = exports.trimInput = exports.padInput = void 0;
var constants_1 = require("../../../shared/src/constants");
var errors_and_warnings_1 = require("./errors-and-warnings");
var utils_1 = require("./utils");
var padInput = function (tf, inputShape) { return function (pixels) {
    var pixelsHeight = pixels.shape[1];
    var pixelsWidth = pixels.shape[2];
    if ((0, constants_1.isFixedShape4D)(inputShape) && (inputShape[1] > pixelsHeight || inputShape[2] > pixelsWidth)) {
        return tf.tidy(function () {
            var height = Math.max(pixelsHeight, inputShape[1]);
            var width = Math.max(pixelsWidth, inputShape[2]);
            var rightTensor = tf.zeros([1, pixelsHeight, width - pixelsWidth, 3,]);
            var bottomTensor = tf.zeros([1, height - pixelsHeight, width, 3,]);
            var topTensor = tf.concat([pixels, rightTensor,], 2);
            var final = tf.concat([topTensor, bottomTensor,], 1);
            return final;
        });
    }
    return pixels;
}; };
exports.padInput = padInput;
var trimInput = function (tf, imageSize, scale) { return function (pixels) {
    var height = imageSize[1] * scale;
    var width = imageSize[2] * scale;
    if (height < pixels.shape[1] || width < pixels.shape[2]) {
        return tf.tidy(function () { return tf.slice(pixels, [0, 0, 0,], [1, height, width, 3,]); });
    }
    return pixels;
}; };
exports.trimInput = trimInput;
var scaleOutput = function (range) { return function (pixels) {
    var endingRange = (0, constants_1.isValidRange)(range) ? range[1] : 255;
    return pixels.clipByValue(0, endingRange).mul(endingRange === 1 ? 255 : 1);
}; };
exports.scaleOutput = scaleOutput;
var getWidthAndHeight = function (tensor) {
    if ((0, constants_1.isFourDimensionalTensor)(tensor)) {
        return [tensor.shape[1], tensor.shape[2],];
    }
    if ((0, constants_1.isThreeDimensionalTensor)(tensor)) {
        return [tensor.shape[0], tensor.shape[1],];
    }
    throw (0, errors_and_warnings_1.GET_INVALID_SHAPED_TENSOR)(tensor.shape);
};
exports.getWidthAndHeight = getWidthAndHeight;
var scaleIncomingPixels = function (tf, range) { return function (tensor) {
    if ((0, constants_1.isValidRange)(range) && range[1] === 1) {
        return tf.mul(tensor, 1 / 255);
    }
    return tensor;
}; };
exports.scaleIncomingPixels = scaleIncomingPixels;
var tensorAsClampedArray = function (tf, tensor) { return tf.tidy(function () {
    var _a = tensor.shape, height = _a[0], width = _a[1];
    var fill = tf.fill([height, width,], 255).expandDims(2);
    return tensor.clipByValue(0, 255).concat([fill,], 2).dataSync();
}); };
exports.tensorAsClampedArray = tensorAsClampedArray;
function getCopyOfInput(input) { return ((0, constants_1.isTensor)(input) ? input.clone() : input); }
exports.getCopyOfInput = getCopyOfInput;
function concatTensors(tf, tensors, axis) {
    if (axis === void 0) { axis = 0; }
    var definedTensors = tensors.filter(utils_1.nonNullable);
    if (definedTensors.length === 0) {
        throw errors_and_warnings_1.GET_UNDEFINED_TENSORS_ERROR;
    }
    var concatenatedTensor = tf.concat(definedTensors, axis);
    tensors.forEach(function (tensor) { return tensor === null || tensor === void 0 ? void 0 : tensor.dispose(); });
    return concatenatedTensor;
}
exports.concatTensors = concatTensors;
;
