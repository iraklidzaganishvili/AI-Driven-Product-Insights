import { ModelDefinitionValidationError, } from '../../../shared/src/constants';
export const warn = (msg) => {
    console.warn(Array.isArray(msg) ? msg.join('\n') : msg);
};
export function isProgress(p) { return p !== undefined && typeof p === 'function'; }
export function isSingleArgProgress(p) { return isProgress(p) && p.length <= 1; }
export const isMultiArgTensorProgress = (p, output, progressOutput) => {
    if (!isProgress(p) || p.length <= 1) {
        return false;
    }
    if (progressOutput === undefined && output === 'tensor') {
        return true;
    }
    return progressOutput === 'tensor';
};
export const isAborted = (abortSignal) => {
    if (abortSignal) {
        return abortSignal.aborted;
    }
    return false;
};
export async function wrapGenerator(gen, postNext) {
    let result;
    for (result = await gen.next(); !result.done; result = await gen.next()) {
        if (postNext) {
            await postNext(result.value);
        }
    }
    return result.value;
}
export function nonNullable(value) {
    return value !== null && value !== undefined;
}
export function processAndDisposeOfTensor(tf, tensor, ..._processFns) {
    const processFns = _processFns.filter(nonNullable);
    if (processFns.length) {
        const processedTensor = tf.tidy(() => processFns.reduce((reducedTensor, processFn) => processFn(reducedTensor), tensor));
        if (!tensor.isDisposed && tensor !== processedTensor) {
            tensor.dispose();
        }
        return processedTensor;
    }
    return tensor;
}
export const errIsModelDefinitionValidationError = (err) => err instanceof ModelDefinitionValidationError;
