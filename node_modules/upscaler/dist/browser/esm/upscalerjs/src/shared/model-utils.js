import { isLayersModel, } from './isLayersModel';
import { ERROR_WITH_MODEL_INPUT_SHAPE, GET_INVALID_PATCH_SIZE, GET_WARNING_PATCH_SIZE_INDIVISIBLE_BY_DIVISIBILITY_FACTOR, MODEL_INPUT_SIZE_MUST_BE_SQUARE, WARNING_INPUT_SIZE_AND_PATCH_SIZE, WARNING_UNDEFINED_PADDING, GET_INVALID_PATCH_SIZE_AND_PADDING, WARNING_DEPRECATED_MODEL_DEFINITION_FN, } from './errors-and-warnings';
import { isShape4D, isFixedShape4D, } from '../../../shared/src/constants';
import { warn, } from './utils';
export const parseModelDefinition = (modelDefinition) => ({
    ...modelDefinition,
});
export function isModelDefinitionFn(modelDefinition) { return typeof modelDefinition === 'function'; }
export function getModelDefinitionOrModelDefinitionFnAsModelDefinition(tf, modelDefinition) {
    if (isModelDefinitionFn(modelDefinition)) {
        warn(WARNING_DEPRECATED_MODEL_DEFINITION_FN);
        return modelDefinition(tf);
    }
    return modelDefinition;
}
export async function getModel(tf, modelDefinition) {
    const modelDef = getModelDefinitionOrModelDefinitionFnAsModelDefinition(tf, modelDefinition);
    if (modelDef.setup) {
        await modelDef.setup(tf);
    }
    return modelDef;
}
export function loadTfModel(tf, modelPath, modelType) {
    if (modelType === 'graph') {
        return tf.loadGraphModel(modelPath);
    }
    return tf.loadLayersModel(modelPath);
}
const getBatchInputShape = (tf, model) => {
    if (isLayersModel(tf, model)) {
        return model.layers[0].batchInputShape;
    }
    return model.inputs[0].shape;
};
export const getModelInputShape = (tf, { model, }) => {
    const batchInputShape = getBatchInputShape(tf, model);
    if (!isShape4D(batchInputShape)) {
        throw new Error(ERROR_WITH_MODEL_INPUT_SHAPE(batchInputShape));
    }
    return batchInputShape;
};
export const getPatchSizeAsMultiple = (divisibilityFactor, patchSize) => {
    return Math.ceil(patchSize / divisibilityFactor) * divisibilityFactor;
};
export const parsePatchAndInputShapes = (tf, modelPackage, { patchSize, padding, }, imageSize) => {
    const modelInputShape = getModelInputShape(tf, modelPackage);
    if (patchSize !== undefined) {
        if (patchSize <= 0) {
            throw GET_INVALID_PATCH_SIZE(patchSize);
        }
        if (padding !== undefined && padding * 2 >= patchSize) {
            throw GET_INVALID_PATCH_SIZE_AND_PADDING(patchSize, padding);
        }
    }
    if (isFixedShape4D(modelInputShape)) {
        if (patchSize !== undefined) {
            warn(WARNING_INPUT_SIZE_AND_PATCH_SIZE);
        }
        if (modelInputShape[1] !== modelInputShape[2]) {
            throw MODEL_INPUT_SIZE_MUST_BE_SQUARE;
        }
        return {
            patchSize: modelInputShape[1],
            padding,
            modelInputShape,
        };
    }
    if (patchSize !== undefined && padding === undefined) {
        warn(WARNING_UNDEFINED_PADDING);
    }
    const { divisibilityFactor, } = modelPackage.modelDefinition;
    if (divisibilityFactor !== undefined) {
        if (patchSize !== undefined) {
            const multipliedPatchSize = getPatchSizeAsMultiple(divisibilityFactor, patchSize);
            if (multipliedPatchSize !== patchSize) {
                warn(GET_WARNING_PATCH_SIZE_INDIVISIBLE_BY_DIVISIBILITY_FACTOR(patchSize, divisibilityFactor, multipliedPatchSize));
            }
            return {
                patchSize: multipliedPatchSize,
                padding,
                modelInputShape: [null, multipliedPatchSize, multipliedPatchSize, 3,],
            };
        }
        return {
            patchSize: undefined,
            padding: undefined,
            modelInputShape: [
                null,
                getPatchSizeAsMultiple(divisibilityFactor, imageSize[1]),
                getPatchSizeAsMultiple(divisibilityFactor, imageSize[2]),
                3,
            ],
        };
    }
    return {
        patchSize,
        padding,
        modelInputShape: undefined,
    };
};
