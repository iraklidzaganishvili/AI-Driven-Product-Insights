import { loadTfModel, parseModelDefinition, } from '../shared/model-utils';
import { ERROR_MODEL_DEFINITION_BUG, getModelDefinitionError, } from '../shared/errors-and-warnings';
import { isValidModelDefinition, } from '../../../shared/src/constants';
import { errIsModelDefinitionValidationError, } from '../shared/utils';
export const CDN_PATH_DEFINITIONS = {
    'jsdelivr': (packageName, version, path) => `https://cdn.jsdelivr.net/npm/${packageName}@${version}/${path}`,
    'unpkg': (packageName, version, path) => `https://unpkg.com/${packageName}@${version}/${path}`,
};
export const CDNS = [
    'jsdelivr',
    'unpkg',
];
export const getLoadModelErrorMessage = (errs, modelPath, internals) => new Error([
    `Could not resolve URL ${modelPath} for package ${internals?.name}@${internals?.version}`,
    'Errors include:',
    ...errs.map(([cdn, err,]) => `- ${cdn}: ${err.message}`),
].join('\n'));
export async function fetchModel(tf, modelConfiguration) {
    const { modelType, _internals, path: modelPath, } = modelConfiguration;
    if (modelPath) {
        return await loadTfModel(tf, modelPath, modelType);
    }
    if (!_internals) {
        throw new Error(ERROR_MODEL_DEFINITION_BUG);
    }
    const errs = [];
    for (const cdn of CDNS) {
        const getCDNFn = CDN_PATH_DEFINITIONS[cdn];
        try {
            const url = getCDNFn(_internals.name, _internals.version, _internals.path);
            return await loadTfModel(tf, url, modelType);
        }
        catch (err) {
            errs.push([cdn, err instanceof Error ? err : new Error(`There was an unknown error: ${JSON.stringify(err)}`),]);
        }
    }
    throw getLoadModelErrorMessage(errs, modelPath || _internals.path, _internals);
}
export const loadModel = async (tf, _modelDefinition) => {
    const modelDefinition = await _modelDefinition;
    try {
        isValidModelDefinition(modelDefinition);
    }
    catch (err) {
        if (errIsModelDefinitionValidationError(err)) {
            throw getModelDefinitionError(err.type, modelDefinition);
        }
        throw new Error(ERROR_MODEL_DEFINITION_BUG);
    }
    const parsedModelDefinition = parseModelDefinition(modelDefinition);
    const model = await fetchModel(tf, parsedModelDefinition);
    return {
        model,
        modelDefinition: parsedModelDefinition,
    };
};
