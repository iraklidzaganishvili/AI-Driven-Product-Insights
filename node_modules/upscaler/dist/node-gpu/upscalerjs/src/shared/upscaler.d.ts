import type { Tensor3D } from '@tensorflow/tfjs-core';
import type { UpscalerOptions, ModelPackage, BASE64, WarmupArgs, UpscaleArgs, TENSOR, MultiArgStringProgress, MultiArgTensorProgress, WarmupSizes, Internals } from './types';
import type { TF } from '../../../shared/src/types';
export declare function getUpscaler<T extends TF, Input>({ tf, getUpscaleOptions, checkValidEnvironment, getImageAsTensor, tensorAsBase64, loadModel, }: Internals<T, Input>): {
    new (opts?: UpscalerOptions): {
        _opts: UpscalerOptions;
        _model: Promise<ModelPackage>;
        ready: Promise<void>;
        _abortController: AbortController;
        execute(image: Input, options: Omit<UpscaleArgs, 'output' | 'progress' | 'progressOutput'> & {
            output: TENSOR;
            progress?: MultiArgStringProgress;
            progressOutput: BASE64;
        }): Promise<Tensor3D>;
        execute(image: Input, options: Omit<UpscaleArgs, 'output' | 'progress' | 'progressOutput'> & {
            output?: BASE64;
            progress?: MultiArgTensorProgress;
            progressOutput: TENSOR;
        }): Promise<string>;
        execute(image: Input, options: Omit<UpscaleArgs, 'output' | 'progress' | 'progressOutput'> & {
            output: TENSOR;
            progress?: MultiArgTensorProgress;
            progressOutput?: unknown;
        }): Promise<Tensor3D>;
        execute(image: Input, options: Omit<UpscaleArgs, 'output' | 'progress' | 'progressOutput'> & {
            output?: BASE64;
            progress?: MultiArgStringProgress;
            progressOutput?: unknown;
        }): Promise<string>;
        execute(image: Input, options: Omit<UpscaleArgs, 'output' | 'progress' | 'progressOutput'> & {
            output?: TENSOR | BASE64;
            progress?: MultiArgStringProgress | MultiArgTensorProgress;
            progressOutput?: unknown;
        }): Promise<Tensor3D | string>;
        execute(image: Input): Promise<string>;
        upscale: {
            (image: Input, options: Omit<UpscaleArgs, 'output' | 'progress' | 'progressOutput'> & {
                output: TENSOR;
                progress?: MultiArgStringProgress;
                progressOutput: BASE64;
            }): Promise<Tensor3D>;
            (image: Input, options: Omit<UpscaleArgs, 'output' | 'progress' | 'progressOutput'> & {
                output?: BASE64;
                progress?: MultiArgTensorProgress;
                progressOutput: TENSOR;
            }): Promise<string>;
            (image: Input, options: Omit<UpscaleArgs, 'output' | 'progress' | 'progressOutput'> & {
                output: TENSOR;
                progress?: MultiArgTensorProgress;
                progressOutput?: unknown;
            }): Promise<Tensor3D>;
            (image: Input, options: Omit<UpscaleArgs, 'output' | 'progress' | 'progressOutput'> & {
                output?: BASE64;
                progress?: MultiArgStringProgress;
                progressOutput?: unknown;
            }): Promise<string>;
            (image: Input, options: Omit<UpscaleArgs, 'output' | 'progress' | 'progressOutput'> & {
                output?: TENSOR | BASE64;
                progress?: MultiArgStringProgress | MultiArgTensorProgress;
                progressOutput?: unknown;
            }): Promise<Tensor3D | string>;
            (image: Input): Promise<string>;
        };
        warmup: (warmupSizes?: WarmupSizes, options?: WarmupArgs) => Promise<void>;
        abort: () => void;
        dispose: () => Promise<void>;
        getModel: () => Promise<ModelPackage>;
    };
};
//# sourceMappingURL=upscaler.d.ts.map